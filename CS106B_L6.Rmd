---
title: "CS106B: Programming Abstractions"
subtitle: "Lecture 6: unordered DS"
author: "Olivia Beyer Bruvik"
date: "Fall 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# Lecture 6 {.tabset}

## Topics
unordered data structures:

- Sets
- Maps

### Associative container: map
- Associates keys with values
    + each could be any type
- Stanford library Map:

```{Rcpp}

void printVector(const Vector<int>& values) {
  for (int elem; values) {
    cout << elem << " ";
  }
  cout << endl;
}
```


### Associative container: set
- Associates keys with membership
    + in or out
- Lexicon: a set of strings
    + with special internal optimizations for that


## SECTION 1A

```{Rcpp}

void printVector(const Vector<int>& values) {
  for (int elem; values) {
    cout << elem << " ";
  }
  cout << endl;
}

// Pass by value: creates copy
void Maui(Vector<int> val) {
  for (int i; i < i.size; i++) {
    val[i] = 1258 * val[i] * (val[2] - val[0]);
  }
}

// Pass by reference in function, but pass by value in for loop: creates copy
void Moana(Vector<int>& values) {
  for (int elem: values) {
    elem *= 137;
  }
}

// Pass by reference in function and for loop: accesses original
void heihei(Vector<int>& val) {
  for (int& elem: val) {
    elem++;
  }
}

// Pass by reference, but creates new variable. 
// Adding const makes sure that original vector does not change (leads to compiling error)
vector teFiti(const Vector<int>& val) {
  Vector<int> result;
  for (int elem: val) {
    result += (elem * 137);
  }
  return result;
}

int main() {
  vector<int 7 vals = {1, 3, 7};
  maui(vals);
  printVector(vals);
  moana(vals);
  printVector(vals);
}

```



```{Rcpp}
void printLyrics_v1() {
  cout << "Havana ooh na na" << endl;
}

string printLyrics_v2() {
  return "Havana ooh na na"; 
}

string printLyrics_v3() {
  return "H"; 
}

char printLyrics_v3() {
  return 'H'; 
}

```



## CS106B Lecture 4

### Topics
1. What is an ADT?
2. Vector ADT
3. Grid ADT

### Abstract Data Types (ADT)
- language-independent models of common containers
- encompass both: 
  + the nature of the data (ordered, paired), and 
  + ways of accessing it (ability to add/remove data, data search)

### Vector ADT
- Similar to array/list
- Use Stanford library Vector, not C++ STL vector (NB! capitalization)
- Must be homogenous (same data type)
- Type goes in the <> after class name Vector

Template syntax
```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

#include "vector.h"                       // note quotes for Stanford version
Vector<string> lines;                     // note uppercase V here
Vector<double> measurementsData;
Vector<Vector<int>> allAssignmentScores;  // 2D vector

// Examples of using a vector
pset3Scores.add(98);
cout << pset3Scores[0] << endl;           // prints 98
cout << pset3Scores.size() << endl;       // prints 1
```

### Vector performance

Performance Warning: insert/remove slower the more elements they shift <br>
`v.insert(2, 42)`: shifts elements right to make room for the element <br>
`v.remove(1)`: shifts element left to cover space left by removed element

Tip: `use v.add()` to add elements at end instead

#### Testing performance
```{Rcpp}
/********** Test Cases ***********/
PROVIDED_TEST("Timing comparison")
{
  int size = 500000;
  TIME_OPERATION(size, runInsert(size));
  TIME_OPERATION(size, runAdd(size));
}
  
```

#### Parameter passing
Always use pass-by-reference for containers like Vector and Grid for efficiency (no copy).

```{Rcpp}
void printFirst(Vector<int>& input) {
  cout << input[0] << endl;
}
```

### Grid container
ADT abstration similar to an array of arrays (matrix)

```{Rcpp}
#include <Rcpp.h>
#include "grid.h"

using namespace Rcpp;

Grid<int> chessboard;
Grid<int> image;
Grid<double> realMatrix;

void printMe(Grid<int>& grid, int row, int col) {
  for (int r = row - 1; r <= row + 1; r++) {
    for (int c = col - 1; c <= col + 1; c++) {
      if (grid.inBounds(r, c)) {
        cout << grid[r][c] << " ";
      }
    }
    cout << endl;
  }
}
```


## CS106B Lecture 3

### Standard string library
Question: extract value between brackets in string, ie. "(blahblah)"

```{r, eval = FALSE}
include <str>
```

```{r, eval = FALSE}
string insidePart = str.substr(1, str.length()-2)
OR
string indexOne = str.find("(")
string indexTwo = str.find(")")
string insidePart = str.substr(indexOne, indexTwo-1)
```

### Stanford string library
- unlike the previous ones, these take the string as a parameter
- read up on this
```{r, eval = FALSE}
#include "strlib.h"
```

### Hamilton code
```{r, eval = FALSE}

#include <iostream>
#include <string>
#include "console.h"
#include "testing/SimpleTest.h"

using namespace std;

const int DAT_AMOUNT = 3;
const int  YA_AMOUNT = 8;

string generateLyrics(int daAmount);

int main()
{
  if (runSimpleTests(SElECTED_TESTS)) {
    return 0
  }
  
  cout 
  ## INSERT MORE
}

string generateLyrics(int daAmount)
{
  string lyrics = "";
  for (int = 1; i <= daAmount; i++) {
    if (i % DAT_AMOUNT == 0) {
      lyrics += "Dat ";
    } else if (i % 8 == 0) {
        lyrics += "Ya Da ";
    } else {
      lyrics =+ "Da ";
    }
  }
  return lyrics
}

```

### Style: writing good tests
- "Good" means thorough: covers all code paths and cases
- Each test (if, else if, else) should be thoughtful
- Extra attentive to unusual circumstances (edge cases)
- These will vary, specific to function you are testing, but common examples include:
  + integer inputs: negative numbers, zero, very large numbers
  + string inputs: very shout strings (length 0 or 1), very long strings


### Default behavior of parameters: what is printed?
A) 5
B) 6
C) Error or something else

```{r, eval = FALSE}
#include <iostream>
void foo(int n);

int main(){
  int n = 5;
  foo(n);
  cout << n << end1;
  return 0;
}

```

#### "Pass by value": prints 5 because of scope
```{r, eval = FALSE}
## Pass by value. prints 5
void foo(int n) {
void foo(int &n) { 
  n++;
}
```

#### "Pass by reference": prints 6
- & think of as rope lasso that grabs the input parameter and drags it into the funciton call directly, rather than making a copy of its value and then leaving it in place. 
- We can also use other names - will grab same "cat"
- Java: pass strings/integers = by value, pass objects = by reference

```{r, eval = FALSE}
## Pass by reference - use ambersand / rope lasso. prints 6
void foo(int &n) { ## Pass by reference - use ambersand / rope lasso
  n++;
}
```

### Ethics
- Soundex is a phonetic algorithm used to identify and group words that sound the same.
- Phonetic algorithms help us identify words
- representational accuracy vs. ease of analysis
- easy to implement + clear rules of grouping words together
- people's names incorrectly grouped together -> lack of representation. 
- consequences:
  + distributive harms (goods / outcomes)
  + equality of opportunity vs. outcome vs. welfare
  + representational harm: American Standard Code for Info Interchange (256 char) vs. Unicode (1e6 char)

### CS106B Testing Framework

In main(), write:
```{r, eval = FALSE}
runSimpleTests(SELECTED_TESTS;
```

Write tests as:
```{r, eval = FALSE}
EXPECT_EQUAL(functionBeingTested(input), expectedOutput);
EXPECT_EQUAL(generateLyrics(2), "Da Da ");
EXPECT_EQUAL(generateLyrics(3), "Da Da Dat ");
EXPECT_EQUAL(generateLyrics('3'), X); # What happens? Error: data type?
EXPECT_EQUAL(generateLyrics(8), "Da Da Dat Da Da Dat Da Ya Da ");

```

### Miscellaneous
- count starts at 0
- constants have ALL_CAPS
- variable names camelCase
- const int - cannot change variable
- LINE UP VARIABLES: 
  + const int DAT_AMOUNT = 3;
  + const int  YA_AMOUNT = 8;
- no magic numbers (random wo/ context)
- text cases comes at bottom of starter code

## Data types

### String literals
  + use double quotes
  + hard-coded string values;
  + "hello" and "123"
  + from old C styles (from days w/o object-oriented programming)
  + no methods
  
### String objects
  + use double quotes
  + objects w/ methods and operators;
  + string s;
  + string piece = s.substr(0,);
  + s.append(t); //or, equivalently: s += t;

### Char
  + use single quotes


```{r, eval = FALSE}

#include "testing/SimpleTest.h"
using namespace std;

string generateLyrics(int daAmount)
{
  string lyrics = ""; ## strings need double quotes in c++. single quotes need single quotes.
  for (int i = 1; i<= daAmount; i++) {
    if (i % 3 == 0) {
      lyrics += "Dat ";
    } else if (i % 8 == 0) {
      lyrics += "Ya Da ";
    } else {
      lyrics += "Da ";
    }
  }
  return lyrics;
}

int main() 
{
  string lyrics = generateLyrics(5);
  cout << lyrics << end1;
  
  return 0;
}

```


### Using cout and strings: String literals vs. C++ string objects

*Two types of strings:*

- String literals:
  + hard-coded string values;
  + "hello" and "123"
  + from old C styles (from days w/o object-oriented programming)
  + no methods
  
- String objects
  + objects w/ methods and operators;
  + string s;
  + string piece = s.substr(0,);
  + s.append(t); //or, equivalently: s += t;

```{r}
int main(){
  
  ## Works
  string s = "ab";
  s = s + "cd";
  
  ## Doesn't work because we cannot concatenate two string literal
  string s = "ab" + "cd";
  cout << s << end1;
  
  return 0;
}
```


### C++ standard string object member functions (3.2)
#include <string>

- s.append(str)
- s.compare(str)
- s.erase(index, length),
- s.find(str)
- s.rfind(str)
- s.insert(index, str)
- s.length() or s.size()
- s.replace(index, len, str)
- s.substr(start, length) or s.substr(start)

string::npos: returned if string not found in search:
```{r}
string name = "Donald Knuth";
if (name.find("Knu") != string::npos) {
  name.erase(5,6);
}
```

